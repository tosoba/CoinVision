import kotlinx.datetime.LocalDateTime;

CREATE TABLE token(
	id TEXT NOT NULL PRIMARY KEY,
	symbol TEXT NOT NULL,
	name TEXT NOT NULL,
	image TEXT
);

CREATE TABLE mainToken(
	id TEXT NOT NULL PRIMARY KEY,
	updatedAt TEXT AS LocalDateTime NOT NULL
);

CREATE TABLE referenceToken(
	id TEXT NOT NULL PRIMARY KEY,
	updatedAt TEXT AS LocalDateTime NOT NULL
);

CREATE TABLE chartPeriod(
    id TEXT NOT NULL PRIMARY KEY,
    period TEXT NOT NULL
);

selectAllMainTokens:
SELECT t.* FROM token t
INNER JOIN mainToken mt ON t.id = mt.id
ORDER BY updatedAt DESC;

selectAllReferenceTokens:
SELECT t.* FROM token t
INNER JOIN referenceToken rt ON t.id = rt.id
ORDER BY updatedAt DESC;

selectMostRecentMainToken:
SELECT t.* FROM token t
INNER JOIN mainToken mt ON t.id = mt.id
WHERE mt.updatedAt = (SELECT MAX(updatedAt) FROM mainToken);

selectMostRecentMainTokenIdWithChartPeriod:
SELECT
COALESCE(
    (
        SELECT t.id FROM token t
        LEFT JOIN mainToken mt ON t.id = mt.id
        WHERE mt.updatedAt = (SELECT MAX(updatedAt) FROM mainToken)
    ),
    'ethereum'
),
COALESCE(
    (SELECT cp.period FROM chartPeriod cp),
    'DAY'
);

selectMostRecentReferenceToken:
SELECT t.* FROM token t
INNER JOIN referenceToken rt ON t.id = rt.id
WHERE rt.updatedAt = (SELECT MAX(updatedAt) FROM referenceToken);

selectChartPeriod:
SELECT period FROM chartPeriod;

deleteAll {
DELETE FROM token;
DELETE FROM mainToken;
DELETE FROM referenceToken;
DELETE FROM chartPeriod;
}

insertMainToken {
INSERT OR REPLACE INTO token(id, symbol, name, image) VALUES(?,?,?,?);
INSERT OR REPLACE INTO mainToken(id, updatedAt) VALUES (?,?);
}

insertReferenceToken {
INSERT OR REPLACE INTO token(id, symbol, name, image) VALUES(?,?,?,?);
INSERT OR REPLACE INTO referenceToken(id, updatedAt) VALUES (?,?);
}

insertChartPeriod:
INSERT OR REPLACE INTO chartPeriod(id, period) VALUES (1,?);
